  const myMessage = `${inputs.message}`;
    let allChannels: any[] = [];
    let cursor: string | undefined = undefined;
    let getID = myMessage.split(" ");
    console.log("getID:" , getID);
    const target_id = getID[1]?.replace("<@", "").replace(">", "");
    console.log("message:" , inputs.message);
    if (target_id) {
        console.log("target:" , target_id);
    }
    const result = [];

    do {
      console.log("Before pause");
      await new Promise(resolve => setTimeout(resolve, 100));
      console.log("After pause");
        const response = await client.conversations.list({
            types: "public_channel",
            limit: 100,
            cursor: cursor,
        });

        if (response.ok) {
          console.log(response);
        }

        if (!response.ok || !Array.isArray(response.channels)) {
            console.log("End of channel list:", response);
            break;
        }

        let calls = 0;
        for (const channel of response.channels) {
          console.log("before puase");
          await new Promise(resolve => setTimeout(resolve, 100));
          console.log("after puase ", calls);
          let place = await client.conversations.members({
            channel: channel.id,
            cursor: cursor,
          });
          calls++;
          console.log ("place:", place);
          if (place.members && place.members.includes("U0266FRGP")) {
            console.log("channel:", channel.name);
            result.push(channel.name);
          }
          while (place.response_metadata?.next_cursor) {
            const cursor1 = place.response_metadata?.next_cursor;
            const newplace = await client.conversations.members({
              channel: channel.id,
              cursor: cursor1,
            });
            if (newplace.members && newplace.members.includes(target_id)) {
              console.log("channel:", channel.name);
              result.push(channel.name);
            }
            place = newplace;
            await new Promise(resolve => setTimeout(resolve, 100));
          }
        }

        const next_cursor = response.response_metadata?.next_cursor;
        if (next_cursor) {
          await client.workflows.triggers.create({
            type: "webhook",
            name: "Expose channels re",
            description: "Paginate channel listing",
            workflow: "#/workflows/expose_channels_re",
            inputs: {
              message: { value: myMessage },
              cursor: { value: next_cursor },
            },
          });
          
        }

        allChannels = allChannels.concat(response.channels);
        cursor = response.response_metadata?.next_cursor;
    } while (cursor);

    let content = "List of channels <@" + target_id + "> is in:\n\n";

    console.log("target_id:", target_id);
    console.log("result array:", result);
    console.log("result length:", result.length);

    for (const channel of result) {
      content += `#${channel}\n`;
    }
    console.log ("content:" , content);
    
    const re = await client.canvases.create({
      title: target_id + "'s Channels",
      description: content,
      channel_id: "C09AHN6V1U7",
    });
    console.log("Canvas created successfully", re);
    
    return { outputs: {} };